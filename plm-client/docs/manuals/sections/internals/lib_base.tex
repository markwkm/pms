\subsection{Util}
The PLM::Util:: module space has the following sub-modules:

\begin{itemize}
\item Cache.pm
\item Config.pm
\item Log.pm
\item Trace.pm
\end{itemize}

\subsubsection{Config.pm}
\index{PLM::Util::Config.pm}
Reads the configuration data from disk and provides an API for accessing it.

\begin{verbatim}
new()
\end{verbatim}
\index{PLM::Util::Config.pm!new()}
Instantiates a new object of type PLM::Util::Config.

\begin{verbatim}
file()
\end{verbatim}
\index{PLM::Util::Config.pm!file()}
Load a file, returning an associative array of values.

\begin{verbatim}
get( $key )
\end{verbatim}
\index{PLM::Util::Config.pm!get()}
Returns an option if it's defined, otherwise returns an empty string.

\begin{verbatim}
set( $key, $value )
\end{verbatim}
\index{PLM::Util::Config.pm!set()}
Sets the config option based on the key and value.

\begin{verbatim}
getKeys()
\end{verbatim}
\index{PLM::Util::Config.pm!getKeys()}
Returns a list of the keys in the config object.

\begin{verbatim}
getHash()
\end{verbatim}
\index{PLM::Util::Config.pm!getHash()}
Returns the hash reference to the internal config object keys.

\subsubsection{Log.pm}
\index{PLM::Util::Log.pm}
Provides an interface for modules \& scripts to log events.

\begin{verbatim}
new()
\end{verbatim}
\index{PLM::Util::Log.pm!new()}
Instantiates a new object of type PLM::Util::Log.

\begin{verbatim}
config( %options )
\end{verbatim}
\index{PLM::Util::Log.pm!config()}
Parses the options passes to new() or can be called after new() with additional config arguments.

\begin{verbatim}
debug( $value )
\end{verbatim}
\index{PLM::Util::Log.pm!debug()}
Sets the debug level for the object.

Debug messages are tested against this level and if they are the same level or higher, they are considered valid and set to the logging target.  Otherwise, they are ignored.

\begin{verbatim}
target( $string )
\end{verbatim}
\index{PLM::Util::Log.pm!target()}
Tells the logging subsystem where to log events.  Valid targets are:

\begin{itemize}
\item stdout
\item stderr
\item email
\item syslog
\item file
\end{itemize}

If you are setting the target to 'file' then you must first set the filename using the filename() call or an earlier config() option.

\begin{verbatim}
filename( optional: $path )
\end{verbatim}
\index{PLM::Util::Log.pm!filename()}
Gets or sets the filename to be used as the log target.  If the filename is not passed to the function, the function only returns the current setting.

\begin{verbatim}
mylog( $level, $text )
\end{verbatim}
\index{PLM::Util::Log.pm!mylog()}
Checks to see if the log message is of a high enough priority and if so, logs it to the log target.

\begin{verbatim}
msg()
\end{verbatim}
\index{PLM::Util::Log.pm!msg()}
Wrapper call for mylog() - no, I don't know why we have two either.

\subsubsection{Trace.pm}
\index{PLM::Util::Trace.pm}
Provides a generic panic and error handling routines to the PLM modules.

\begin{verbatim}
trace_configure( $log_ref, $config_ref )
\end{verbatim}
\index{PLM::Util::Trace.pm!trace\_configure()}
Takes a reference to a PLM::Util::Log object and a reference to a PLM::Util::Config 
object for later use.

\begin{verbatim}
panic( $reason_txt )
\end{verbatim}
\index{PLM::Util::Trace.pm!panic()}
Calls the call\_trace routine with the proper options to do a call trace and 
to follow with a panic.

\begin{verbatim}
call_trace( $reason_txt, $panic_trigger )
\end{verbatim}
\index{PLM::Util::Trace.pm!call\_trace()}
Generates a call trace based on the \$reason\_txt passed to the function.  
If the \$panic\_trigger value is != 0, then the module also exits with a 
error value.

\begin{verbatim}
trace_output( $txt, $msg )
\end{verbatim}
\index{PLM::Util::Trace.pm!trace\_output()}
Helper function that takes the \$msg generated by call\_trace() and both logs
it through the regular logging channel and emails it to the administrator of 
the PLM system.

\begin{verbatim}
db_check( $dbh, $sql )
\end{verbatim}
\index{PLM::Util::Trace.pm!db\_check()}
Checks the error values of the given \$dbh handle and if the last command 
given was an error, then it generates a panic() on the error values and the
included \$sql command string.
